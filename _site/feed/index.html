<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>Kevin</title>
    <link href="https://xiangshuai.github.com//feed/" rel="self" />
    <link href="http://geeklu.com" />
    <lastBuildDate>2014-12-06T21:08:41+08:00</lastBuildDate>
    <webMaster>kejinlu@gmail.com</webMaster>
    
    <item>
      <title>N个点求最大斜率</title>
      <link href="https://xiangshuai.github.com//2014/10/Find-MaxK-from-N-points/"/>
      <pubDate>2014-10-04T00:00:00+08:00</pubDate>
      <author>Kevin</author>
      <guid>https://xiangshuai.github.com//2014/10/Find-MaxK-from-N-points</guid>
      <content:encoded><![CDATA[<h2>面试题：</h2>

<p>平面上N个点，每两个点都确定一条直线，求出斜率最大的那条直线所通过的两个点（斜率不存在的情况不考虑）。时间效率越高越好。</p>

<h3>分析：</h3>

<p>3个点A,B,C,把它们的按x坐标排序。假设排序后的顺序是ABC，那么有两种情况：</p>

<pre><code>1.ABC共线，则k(AB)=k(BC)=k(AC)
2.ABC不共线，则ABC将形成一个三角形，那么k(AC)&lt;max(k(AB), k(BC))
</code></pre>

<p>其中k()表示求斜率。
所以程序的基本步骤就是：</p>

<pre><code>1.把N个点按x坐标排序。
2.遍历，求相邻的两个点的斜率，找最大值。
</code></pre>

<p>复杂度Nlog(N)。</p>

<p>先把这些点按x坐标从小到大排序，斜率最大的两点必然是挨一起的两个点，所以排序O(n* lg n)，遍历一次O(n)就够了。</p>

<h3>代码：</h3>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cfloat&gt;

using namespace std;
class Point
{
public:
    Point(float x, float y):x(x),y(y){}
public:
    float x;
    float y;
};

bool less_first(const Point &amp;pt1, const Point &amp;pt2)
{
    return pt1.x &lt; pt2.x;
}

void printPts(const vector&lt;Point&gt; pts)
{
    for(int i=0; i&lt;pts.size(); i++)
    {
        cout &lt;&lt; "point " &lt;&lt; i &lt;&lt; ": (" &lt;&lt;pts[i].x &lt;&lt; "," &lt;&lt; pts[i].y &lt;&lt; ")"&lt;&lt; endl;
    }
}

float findMaxK(const vector&lt;Point&gt; &amp;pts, int &amp;index)
{
    float maxK = FLT_MIN;
    for(int i=1; i&lt;pts.size(); i++)
    {
        Point pt1 = pts[i-1];
        Point pt2 = pts[i];
        float k = (pt2.y-pt1.y)/(pt2.x-pt1.x); // 斜率(point[i-1],point[i]))
        if(maxK &lt; k)
        {
            maxK = k;
            index = i;
        }
    }
    return maxK;
}

int main()
{
    vector&lt;Point&gt; points;
    points.push_back(Point(2.3, 3.5));
    points.push_back(Point(7.2, 3.5));
    points.push_back(Point(5.5, 6.4));
    points.push_back(Point(2.3, 1.3));
    points.push_back(Point(6.6, 8.1));
    points.push_back(Point(1.7, 6.0));
    points.push_back(Point(4.8, 5.4));
    points.push_back(Point(0.7, 7.5));
    //printPts(points);

    // N个点按x排序
    sort(points.begin(), points.end(), less_first);
    printPts(points);

    int index;
    float maxK = findMaxK(points, index);
    cout &lt;&lt; "max k: " &lt;&lt; maxK &lt;&lt; " generated by point " &lt;&lt; index - 1 &lt;&lt; " and point " &lt;&lt; index &lt;&lt; "." &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>策略模式</title>
      <link href="https://xiangshuai.github.com//2014/09/Strategy-Pattern/"/>
      <pubDate>2014-09-10T00:00:00+08:00</pubDate>
      <author>Kevin</author>
      <guid>https://xiangshuai.github.com//2014/09/Strategy-Pattern</guid>
      <content:encoded><![CDATA[<h2>1. 定义</h2>

<p>策略模式体现了这样两个原则——封装变化和对接口编程而不是对实现编程。设计模式的作者把策略模式定义如下：</p>

<blockquote><p>Define a family of algorithms, encapsulate each one, and make them interchangeable. [The] Strategy [pattern] lets the algorithm vary independently from clients that use it.</p>

<p>(策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而变化。)</p></blockquote>

<h2>2. 实现</h2>

<h3>2.1 基本结构</h3>

<p><img src="http://xiangshuai.github.io/resources/Strategy-Pattern-2014213800.png" alt="" /></p>

<h3>2.2 流程</h3>

<ol>
<li>为策略对象定义Strategy接口。</li>
<li>编写ConcreteStrategy类实现Strategy接口，ConcreteStrategy包装相关算法和行为。</li>
<li>在Context类中，保持对Strategy对象的私有引用。</li>
<li>在Context类中，实现Strategy对象的set和get方法。
Strategy接口定义了Strategy对象的行为；具体的ConcreteStrategy类实现了Strategy接口；Context类使用Strategy对象。</li>
</ol>


<h2>3. 应用</h2>

<ol>
<li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。</li>
<li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。</li>
<li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的 Strategy类中以代替这些条件语句。</li>
</ol>


<h2>4. 实例</h2>

<h3>4.1 简单购物车</h3>

<p>在实现购物车应用时，关于支付方式可能需要提供多种策略，比如信用卡支付或PayPal等网上支付方式，通过策略模式进行简单实现，类图如下：</p>

<p><img src="http://xiangshuai.github.io/resources/Strategy-Pattern-2014213900.png" alt="" /></p>

<p>具体实现详见：<a href="http://www.journaldev.com/1754/strategy-design-pattern-in-java-example-tutorial">Strategy Design Pattern in Java – Example Tutorial</a></p>

<h3>4.2 Java Comparable and Comparator</h3>

<p>定义Strategy：</p>

<pre><code>public interface Comparator {
    public int compare(Object o1, Object o2);
}
</code></pre>

<p>日期类实现Strategy接口：</p>

<pre><code>public class DateComparator implements Comparator {
    public int compare(Object o1, Object o2) {
        return ((Date) o1).compareTo((Date) o2);
    }
}
</code></pre>

<p>字符串比较类实现Strategy接口：</p>

<pre><code>public class StringIntegerComparator implements Comparator {
    public int compare(Object o1, Object o2) {
        return Integer.parseInt((String) o1) -Integer.parseInt((String) o2);
    }
}
</code></pre>

<p>倒转行为实现Strategy接口：</p>

<pre><code>public class ReverseComparator implements Comparator {
    private final Comparator c;
    public ReverseComparator(Comparator c) {this.c = c; }
    public int compare(Object o1, Object o2) {
        return c.compare(o2, o1);
    }
}
</code></pre>

<p>在对String数组逆序输出时，便可使用：</p>

<pre><code>Arrays.sort(stringArray, new ReverseComparator(new StringIntegerComparator()));
</code></pre>

<p>后续...</p>

<h2>5. 参考：</h2>

<ol>
<li><a href="http://www.journaldev.com/780/java-comparable-and-comparator-example-to-sort-objects">Java Comparable and Comparator Example to sort Objects</a></li>
<li><a href="https://thenewcircle.com/static/bookshelf/java_fundamentals_tutorial/design_patterns.html">Java Fundamentals Tutorial : Design Patterns</a></li>
<li><a href="http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns">Examples of GoF Design Patterns</a></li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>在Cygwin中安装Jekyll</title>
      <link href="https://xiangshuai.github.com//2014/08/Install-Jekyll-in-Cygwin/"/>
      <pubDate>2014-08-31T00:00:00+08:00</pubDate>
      <author>Kevin</author>
      <guid>https://xiangshuai.github.com//2014/08/Install-Jekyll-in-Cygwin</guid>
      <content:encoded><![CDATA[<p>前段时间发现<a href="https://www.cygwin.com/">Cygwin</a>，可以在windows平台模拟linux下的大部分环境，而且通过其管理git也非常方便，但是在Cygwin下配置jekyll是遇到许多问题，也在网上找了许多方法，尝试了好久最后终于配置成功，在这里记录一下，以后再次配置时能够轻松一点。</p>

<p>安装jekyll需要ruby环境，这里通过rvm进行ruby环境的安装。另外，还需要一些依赖包：<em>patch，zlib-devel，openssl，openssl-devel，libyaml-devel，libyaml0_2，sqlite3，make，libtool，gcc-core，autoconf，automake，bison，m4，mingw64-i686-gcc，mingw64-x86_64-gcc，cygwin32-readline</em>等，如果不想逐个安装，最好先把Cygwin的包管理软件配置一下。</p>

<p><strong>1. 配置包管理环境：</strong></p>

<pre><code>cp /cygdrive/f/package/setup-x86_64.exe /usr/local/bin/setup-x86_64.exe
</code></pre>

<p><em>注：setup-x86[<em>64].exe名字不能改，因为自动进行软件下载时，会使用setup-x86[</em>64].exe命令进行下载，所以要确保名字无误，否则可能安装失败。</em></p>

<p><strong>2. 安装rvm</strong></p>

<pre><code>curl -L https://get.rvm.io | bash -s stable –ruby
</code></pre>

<p>安装完rvm，根据控制台输出日志启动rvm，日志信息如下：</p>

<p><img src="http://xiangshuai.github.io/resources/20140831201602.jpg" alt="" /></p>

<p><strong>3. 启动rvm后，安装ruby（如果ruby版本低于2.1时）</strong></p>

<pre><code>rvm list known
rvm install 2.1
rvm use 2.1 --default
</code></pre>

<p><strong>4. 安装jekyll</strong></p>

<pre><code>gem update --system
gem list
gem install jekyll
</code></pre>

<p><em>安装jekyll可能会出错，错误信息：</em></p>

<p><img src="http://xiangshuai.github.io/resources/20140831201702.jpg" alt="" /></p>

<p>错误主要是由ffi-1.9.3.gem安装的问题，可在<a href="https://github.com/ffi/ffi/issues/284">这里</a>找到解决方法，具体如下图：</p>

<p><img src="http://xiangshuai.github.io/resources/20140831201802.jpg" alt="" /></p>

<p>即：在Cygwin中安装<em>libffi6，libffi-devel，cygwin32-libffi，pkg-config</em>，并将PKG_CONFIG_PATH指向为/lib/pkgconfig。</p>

<pre><code>export PKG_CONFIG_PATH="/lib/pkgconfig"
</code></pre>

<p>再次安装jekyll便可顺利安装<em>ffi-1.9.3</em>了：</p>

<p><img src="http://xiangshuai.github.io/resources/20140831201902.jpg" alt="" /></p>

<p>这样，就可以在Cygwin中成功安装jekyll了 ^_^ ！</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>数学在计算机图形学中的应用--转</title>
      <link href="https://xiangshuai.github.com//2014/08/Mathematics-for-Computer-Graphics/"/>
      <pubDate>2014-08-28T00:00:00+08:00</pubDate>
      <author>Kevin</author>
      <guid>https://xiangshuai.github.com//2014/08/Mathematics-for-Computer-Graphics</guid>
      <content:encoded><![CDATA[<p> “学习计算机图形学需要多少的数学？”这是初学者最经常问的问题。答案取决于你想在计算机图形学领域钻研多深。如果仅仅使用周围唾手可得的图形软件，你不需要知道多少数学知识。如果想学习计算机图形学的入门知识，我建议你读一读下面所写的前两章（代数，三角学和线性代数）。如果想成为一名图形学的研究者，那么对数学的学习将是活到老，学到老。</p>

<p>如果你并不特别喜欢数学，是否仍有在计算机图形学领域工作的机会？是的，计算机图形学的确有一些方面不需要考虑太多的数学问题。你不应该因为数学成绩不好而放弃它。不过，如果学习了更多的数学知识，似乎你将在研究课题上有更多的选择余地。</p>

<p>对于在计算机图形学中哪些数学才是重要的还没有明确的答案。这领域里不同的方面要求掌握不同的数学知识，也许兴趣将会决定了你的方向。以下介绍我认为对于计算机图形学有用的数学。别以为想成为一名图形学的研究者就必须精通各门数学！为了对用于图形学的数学有一个全面的看法，我特地列出了很多方面。但是许多研究者从不需要考虑下面提到的数学。</p>

<p>最后，虽然读了这篇文章后，你应该会对数学在计算机图形学中的应用有所了解，不过这些观点完全是我自己的。也许你应该阅读更多的此类文章，或者至少从其他从事计算机图形学工作的人那里了解不同的学习重点。现在开始切入正题。</p>

<h2>代数和三角学</h2>

<p>对于计算机图形学的初学者来说，高中的代数和三角学可能是最重要的数学。日复一日，我从简单的方程解出一个或更多的根。我时常还要解决类似求一些几何图形边长的简单三角学问题。代数和三角学是计算机图形学的最基础的知识 。</p>

<p>那么高中的几何学怎么样呢？可能让人惊讶，不过在多数计算机图形学里，高中的几何学并不经常被用到。原因是许多学校教的几何学实际上是如何建立数学证明的课程。虽然证明题对提高智力显然是有效的，但对于计算机图形学来说，那些与几何课有关的定理和证明并不常被用到。如果你毕业于数学相关领域（包括计算机图形学），就会发现虽然你在证明定理，不过这对开始学习图形学不是必要的。</p>

<p>如果精通代数和三角学，就可以开始读一本计算机图形学的入门书了。下一个重要的用于计算机图形学的数学——线性代数，多数此类书籍至少包含了一个对线性代数的简要介绍。</p>

<p>推荐的参考书:</p>

<ul>
<li>Computer Graphics: Principles and Practice</li>
</ul>


<p>James Foley, Andries van Dam, Steven Feiner, John Hughes.
Addison-Wesley
[虽然厚重，可是我很喜欢]</p>

<h2>线性代数</h2>

<p>线性代数的思想贯穿于计算机图形学。事实上，只要牵涉到几何数值表示法，就常常抽象出例如x,y,z坐标之类的数值，我们称之为矢量。图形学自始至终离不开矢量和矩阵 。用矢量和矩阵来描述旋转，平移，或者缩放是再好不过了。高中和大学都有线性代数的课程。只要想在计算机图形学领域工作，就应该打下坚实的线性代数基础。我刚才提到，许多图形学的书都有关于线性代数的简要介绍——足够教给你图形学的第一门课。</p>

<p>推荐的参考书:</p>

<ul>
<li>Linear Algebra and Its Applications</li>
</ul>


<p>Gilbert Strang.
Academic Press</p>

<h2>微积分学</h2>

<p>微积分学是高级计算机图形学的重要成分。如果打算研究图形学，我强烈建议你应该对微积分学有初步认识。理由不仅仅是微积分学是一种很有用的工具，还有许多研究者用微积分学的术语来描述他们的问题和解决办法。另外，在许多重要的数学领域，微积分学被作为进一步学习的前提。学习了基本代数之后，微积分学又是一种能为你打开多数计算机图形学与后继的数学学习之门的课程。
微积分学是我介绍的最后一个中学课程，以下提及的科目几乎全部是大学的课程。</p>

<h2>微分几何学</h2>

<p>微分几何学研究支配光滑曲线，曲面的方程组。如果你要计算出经过某个远离曲面的点并垂直于曲面的矢量（法向矢量）就会用到微分几何学。让一辆汽车以特定速度在曲线上行驶也牵涉到微分几何学。有一种通用的绘制光滑曲面的图形学技术，叫做“凹凸帖图”，这个技术用到了微分几何学。如果要着手于用曲线和曲面来创造形体（在图形学里称之为建模）你至少应该学习微分几何学的基础。</p>

<p>推荐的参考书:</p>

<ul>
<li>Elementary Differential Geometry</li>
</ul>


<p>Barrett O'Neill.
Academic Press</p>

<h2>数值方法</h2>

<p>几乎任何时候，我们在计算机里用近似值代替精确值来表示和操作数值，所以计算过程总是会有误差。而且对于给定的数值问题，常常有多种解决的方法，一些方法会更块，更精确或者对内存的需求更少。数值方法研究的对象包括“计算方法”和“科学计算”等等。这是一个很广阔的领域，而且我将提及的其他几门数学其实是数值方法的一些分支。这些分支包括抽样法理论，矩阵方程组，数值微分方程组和最优化。</p>

<p>推荐的参考书:</p>

<ul>
<li>Numerical Recipes in C: The Art of Scientific Computing</li>
</ul>


<p>William Press, Saul Teukolsky, William Vetterling. and Brian Flannery.
Cambridge University Press
[这本参考书很有价值可是很少作为教材使用]</p>

<h2>采样理论和信号处理</h2>

<p>在计算机图形学里我们反复使用储存在正规二维数组里的数字集合来表示一些对象，例如图片和曲面。这时，我们就要用抽样法来表示这些对象。如果要控制这些对象的品质，抽样法理论就变得尤为重要。抽样法应用于图形学的常见例子是当物体被绘制在屏幕上时，它的轮廓呈现锯齿状的边缘。这锯齿状的边缘（被认为是“混淆”现象）是非常让人分散注意力的，用抽样法中著名的技术例如回旋，傅立叶变换，空间和频率的函数表示就能把这个现象减少到最小。这些思想在图像和音频处理领域是同样重要的。</p>

<p>推荐的参考书:
- The Fourier Transform and Its Applications</p>

<p>Ronald N. Bracewell.
McGraw Hill</p>

<h2>矩阵方程组</h2>

<p>计算机图形学的许多问题要用到矩阵方程组的数值解法。一些涉及矩阵的问题包括：找出最好的位置与方向以使对象们互相匹配（最小二乘法），创建一个覆盖所给点集的曲面，并使皱折程度最小（薄板样条算法），还有材质模拟，例如水和衣服等。在图形学里矩阵表述相当流行，因此在用于图形学的数学中我对矩阵方程组的评价是很高的。</p>

<p>推荐的参考书:</p>

<ul>
<li>Matrix Computations</li>
</ul>


<p>Gene Golub and Charles Van Loan.
Johns Hopkins University Press</p>

<h2>物理学</h2>

<p>物理学显然不是数学的分支，它是自成一家的学科。但是在计算机图形学的某些领域，物理学和数学是紧密联系的。在图形学里，牵涉物理学的问题包括光与物体的表面是怎样互相影响的，人与动物的移动方式，水与空气的流动。为了模拟这些自然现象，物理学的知识是必不可少的。这和解微分方程紧密联系，我将会在下一节提到微分方程。</p>

<h2>微分方程的数值解法</h2>

<p>我相信对于计算机图形学来说，解微分方程的技巧是非常重要的。像我们刚才讨论的，计算机图形学致力于模拟源于真实世界的物理系统。波浪是怎样在水里形成的，动物是怎样在地面上行走的，这就是两个模拟物理系统的例子。模拟物理系统的问题经常就是怎样解微分方程的数值解。请注意，微分方程的数值解法与微分方程的符号解法是有很大差异的。符号解法求出没有误差的解，而且时常只用于一些非常简单的方程。有时大学课程里的“微分方程”只教符号解法，不过这并不会对多数计算机图形学的问题有帮助。</p>

<p>在对物理系统的模拟中，我们把世界细分为许多表示成矢量的小元素。然后这些元素之间的关系就可以用矩阵来描述。虽然要处理的矩阵方程组往往没有很精确的解，但是取而代之的是执行了一系列的计算，这些计算产生一个表示成数列的近似解。这就是微分方程的数值解法。请注意，矩阵方程的解法与微分方程数值解法的关系是很密切的。</p>

<h2>最优化</h2>

<p>在计算机图形学里，我们常常为了期望的目标寻求一种合适的描述对象或者对象集的方法。例如安排灯的位置使得房间的照明看起来有种特殊的“感觉”，动画里的人物要怎样活动四肢才能实现一个特殊的动作，怎样排版才不会使页面混乱。以上这些例子可以归结为最优化问题。十年前的计算机图形学几乎没有最优化技术的文献，不过最近这个领域越来越重视最优化理论。我认为在计算机图形学里，最优化的重要性将会日益增加。</p>

<p>推荐的参考书:</p>

<ul>
<li><a href="http://www.stanford.edu/~boyd/cvxbook/">Convex Optimization</a></li>
</ul>


<p>Stephen Boyd and Lieven Vandenberghe.
Cambridge University Press</p>

<h2>概率论与统计学</h2>

<p>计算机图形学的许多领域都要用到概率论与统计学。当研究者涉足人类学科时，他们当然需要统计学来分析数据。图形学相关领域涉及人类学科，例如虚拟现实和人机交互(HCI)。另外，许多用计算机描绘真实世界的问题牵涉到各种未知事件的概率。两个例子：一棵成长期的树,它的树枝分杈的概率；虚拟的动物如何决定它的行走路线。最后，一些解高难度方程组的技巧用了随机数来估计方程组的解。重要的例子：蒙特卡罗方法经常用于光如何传播的问题。以上仅是一部分在计算机图形学里使用概率论和统计学的方法。</p>

<h2>计算几何学</h2>

<p>计算几何学研究如何用计算机高效地表示与操作几何体。典型问题如，碰撞检测，把多边形分解为三角形，找出最靠近某个位置的点，这个学科包括了运算法则，数据结构和数学。图形学的研究者，只要涉足创建形体（建模），就要大量用到计算几何学。</p>

<p>推荐的参考书:</p>

<ul>
<li>Mark de Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf. Computational geometry: algorithms and applications (2th Edition). Springer.</li>
<li>Joseph O'Rourke，Computational Geometry in C。Cambridge University Press</li>
<li>Franco Preparata and Michael Shamos，Computational Geometry: An Introduction。Springer-Verlag
[很经典，不过有点旧了]</li>
</ul>


<h2>总结：数学应用和数学理论</h2>

<p>对于图形学来说，以上提到的许多数学学科都有个共同点：比起这些数学的理论价值，我们更倾向于发掘它们的应用价值。不要惊讶。图形学的许多问题和物理学者与工程师们研究的问题是紧密联系的，并且物理学者与工程师们使用的数学工具正是图形学研究者们使用的。多数研究纯数学理论的学科从不被用于计算机图形学，不过这不是绝对的。请注意这些特例：分子生物学正利用节理论（Knot Theory）来研究DNA分子动力学，亚原子物理学用到了抽象群论。也许有一天，纯数学理论也能推动计算机图形学的发展，谁知道呢？</p>

<p>有些看来重要的数学实际上在计算机图形学里不常被用到。可能拓扑学是此类数学中最有意思的。用一句话来形容拓扑学，它研究油炸圈饼与咖啡杯为什么在本质上是相同的。答案是他们都是只有一个洞的曲面。我们来讨论一下拓扑学的思想。虽然曲面是计算机图形学的重要成分，不过微分几何学的课程已经涵盖了多数对图形学有用的拓扑学知识。微分几何学研究曲面的造型，可是拓扑学研究曲面的相邻关系。我觉得拓扑学对于图形学来说几乎没用，这是由于拓扑学关心抽象的事物，而且拓扑学远离了多数图形学的核心——三维欧氏空间的概念 。对于图形学来说，拓扑学的形式（符号表示法）是表达思想的简便方法，不过图形学很少用到抽象拓扑学的实际工具。对图形学来说，拓扑学像一个好看的花瓶，不过别指望它能立即带给你回报。</p>

<p>有人曾经这么问我，计算机图形学是否用到了抽象代数（群论，环，等等….）或者数论。我没怎么遇到过。和拓扑学一样，这些学科有很多美好的思想。可是很不幸，这些思想很少用于计算机图形学。</p>

<h2>Re:</h2>

<p>[译]<a href="http://www.cc.gatech.edu/~turk/math_gr.html">Mathematics for Computer Graphics. Greg Turk, August 1997</a></p>

<p>作者翻译的非常好，我想应该是有理工科的高等教育背景吧。非常感谢作者的翻译，让这么好的一篇文章为更多的中国读者所接受。
谈谈对这篇文章的看法，我想，文章中提到一些数学分支，按照我们国家的教育体制，只有上到硕士研究生阶段的理工科学生才能全部涉及到，例如：数值方法就是很多工科硕士研究阶段的教授科目；我对文章中关于课本知识偏重于证明以构建完备的数学理论框架，而这对实际应用没有直接帮助的观点是非常有共鸣的；理论和实践是相互依存，而又相互区别的；从读懂一篇 SIGRAPH的论文，到把它变为实际的程序，对于一个熟练的图形程序员来说，至少是3个月的时间，这是理论与实践之间的距离。</p>

<p>文章对于图形学涉及的数学门类的分析，力求全面；事实上，很难有一个人能全部精通全部的知识，对于图形学的学习和实践，应当采取掌握较为宽广的数学知识基础，在需要的时候，对相关知识进行深入的策略；
不要因为自身数学知识的匮乏而沮丧，更不能因此而敌视数学，我想保持乐观上进的态度是学习图形学的关键。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>shooter subtitle downloader详细分析</title>
      <link href="https://xiangshuai.github.com//2014/08/shooter-subtitle-downloader/"/>
      <pubDate>2014-08-23T00:00:00+08:00</pubDate>
      <author>Kevin</author>
      <guid>https://xiangshuai.github.com//2014/08/shooter-subtitle-downloader</guid>
      <content:encoded><![CDATA[<h2>1. 动机</h2>

<p>前段时间刚刚学习了一下Python，感觉Python确实非常的简单和强大，碰巧逛微博时发现了伯乐在线上面的一篇文章：<a href="http://blog.jobbole.com/75244/">“你所写过的最好的Python脚本是什么？”</a>其中有个叫<a href="https://github.com/manojmj92/subtitle-downloader">subtitle-downloader</a>的脚本引发了我的兴趣。此脚本可以根据电影在网上下载对应的字幕，可惜只能在<a href="http://thesubdb.com/">thesubdb</a>网下载英文字幕。由于我也非常喜欢看电影，所以萌生了可下载中文字幕的Python脚本，也作为这段时间学习Python语言的实践总结。</p>

<h2>2. 国内字幕网站</h2>

<p>国内比较知名的字幕网站有<a href="http://www.yyets.com/" title="人人影视">人人影视</a>和<a href="http://www.shooter.cn/" title="射手网">射手网</a>，所以分别分析了一下两个网站的html请求，主要采用firefox和超级赞的firebug插件进行分析。</p>

<h3>2.1 <a href="http://www.yyets.com/">人人影视</a>：</h3>

<p>首先我个人非常喜欢人人影视提供的字幕，字幕质量高且字体漂亮精致，所以我就先对人人影视网站的html文件进行分析，分析结果比较失望。主要有以下方面原因：</p>

<blockquote><ol>
<li>许多电影的字幕人人影视都没有收录</li>
<li>电影字幕主要通过关键字进行搜索，下载的字幕可能与实际电影不同步</li>
<li>没有发现有提供的相关的API进行下载字幕</li>
</ol>
</blockquote>

<h3>2.2 <a href="http://www.shooter.cn/">射手网</a>：</h3>

<p>接着进行射手网的html分析，意外发现了一个惊喜，射手网除了提供关键字进行检索，而且可通过html5和Md5技术进行精确匹配电影文件对应的字幕，测试了几个文件，都搜寻到了结果，而且下载到的字幕也比较令人满意，所以最终采用射手网提供的字幕和基本流程进行Python脚本的开发。</p>

<h2>3. 详细分析射手网精确匹配流程</h2>

<p>由于采用了比较文件hash值进行检索字幕，所以匹配到字幕的精度非常的高，通过进行实际操作和对射手网的html和javascript脚本进行分析，得到了精确匹配字幕的大致流程：</p>

<blockquote><ol>
<li>通过拖拽文件到搜索框</li>
<li>通过html5技术中的文件操作进行文件处理，这里没有上传整个文件，仅仅上传了文件中的4段分片（每段分片大概4KB），总计16KB</li>
<li>通过SparkMd5对上传的4段分片进行hash值计算，合在一起作为此文件的唯一标记filehash</li>
<li>通过filehash即文件名获取此文件对应的字幕文件列表，并以json格式输出</li>
<li>json中的每条则记录了字幕的链接和其对应延时等信息</li>
<li>通过json中提供的链接便可下载对应电影的字幕文件</li>
</ol>
</blockquote>

<p>关于上述的精确匹配过程，主要是通过分析<a href="http://www.shooter.cn/a/sphash.js">sphash.js</a>的脚本和url测试得知，下面主要对其进行分析：</p>

<h3>3.1 <a href="http://www.shooter.cn/a/sphash.js">sphash.js</a>关键代码：</h3>

<p>sphash脚本主要进行文件的分片和各个分片hash值得计算，关键通过以下两段代码实现。</p>

<p>3.1.1 文件分片代码</p>

<pre><code>a.CalcFileHashs = function (d) {
        var e = 4096;
        var c = Math.min(d.size, 4096);
        a.getSliceHash(d, c, Math.min(c + e, d.size), 0);
        c = Math.floor(d.size / 3 * 2);
        a.getSliceHash(d, c, Math.min(c + e, d.size), 1);
        c = Math.floor(d.size / 3);
        a.getSliceHash(d, c, Math.min(c + e, d.size), 2);
        c = Math.max(0, d.size - 8192);
        a.getSliceHash(d, c, Math.min(c + e, d.size), 3)
    };
</code></pre>

<p>上面函数参数d代表文件的基本信息包括：大小、文件路径等信息，主要进行文件分片操作，可看出每个分片大致为4096字节。下图为d的格式：
<img src="http://xiangshuai.github.io/resources/20140823185020.png" alt="" /></p>

<p>3.1.2 hash值计算代码</p>

<pre><code>a.getSliceHash = function (g, i, d, h) {
        var c = new FileReader();
        c.onload = function (j) {
            if (j.target.readyState == FileReader.DONE) {
                var f = j.target.result;
                var k = new SparkMD5.ArrayBuffer();
                k.append(f);
                a.addSliceHash(k.end(), h)
            }
        };
        var e = g.slice(i, d, 'application/experimental');
        c.readAsArrayBuffer(e)
    };
</code></pre>

<p>上述代码的作用是对某个分片进行读取并通过SparkMD5算法进行hash值计算，关于SparkMD5算法比较复杂，感兴趣自行分析，这里就不做分析了。</p>

<h3>3.2 url测试：</h3>

<p>通过获取到文件4个分片的hash值，变可以精确的进行文件匹配。主要通过以下两个url请求。
3.2.1 获取对应文件的字幕列表</p>

<pre><code>https://www.shooter.cn/api/subapi.php?filehash=d751294c05ec7ce0dad50ba97807cac6%3Bde12cb6be164a22a7db10d9fb69d6db5%3Bd1a9a584d3a1846cd0fc7711b8ba40ed%3B0b9a6ceb459802fcec506e2f98d10392&amp;pathinfo=Divergent.2014.RETAIL.1080p.WEB-DL.H264.AC3-EVO.mkv&amp;format=json
</code></pre>

<p>通过上面url可得到返回的字幕列表，并以json格式输出：</p>

<pre><code>[{"Desc":"","Delay":0,"Files":[{"Ext":"srt","Link":"https://www.shooter.cn/api/subapi.php?fetch=MTQwODc5NjY1N3wwMms0NGRCNC1UNmZPekdvLXJfRko2bU8zNkE1eGFyWndlRzFSOC1OZUFKOWpCRVMtVEc4MmZXTVlwNjR6NjdiZkpUZW12eG9JRjFWRHgwN01QWnc2Y01vZGlhRUl1NHMxbm1UT3ZPa1UwZXhheTc1SkJqRlhrOFc3cWQ1RjROWXg1aWRJTlJ5NDBfMGN4UjUwZjFJVC1SYzBqRTRwUU1CM2pRMGQtWT18oXpmBxVzkrWQj2gHyNldXfRT2FhEZI9eOPbRR8RNulc=\u0026nonce=%98%EA-%0F%BFr%AA%17%81%E0%5EU%83~%88%DB"}]},
{"Desc":"","Delay":0,"Files":[{"Ext":"srt","Link":"https://www.shooter.cn/api/subapi.php?fetch=MTQwODc5NjY1N3xqc3RVNVVFMl83OXVJMVhhVjZGQUpOS2UxMVFQSzFRWmdGc2huaVBNVG05UDNobVJYeWg0NlcyN3FmZTFKUUVPaHk3Y01iNVNGbmM3ZS13M2dCWkc1by0tUVg4Yy1JbEN5b3RBWURvUkViY3RzSkdhWnJSRTNubERXZ0JJYVpNc3JUSW9RV01YQWRGYjV0MklIanVuRXdCQVV6UXhDWDZFaVFJN3FlZz18G86t0qzz5vpC6_1ObZWtI-sp4h7qI7ZtiTmlTFRANBM=\u0026nonce=J%CCF%B7%88%B6s%A6%FD%B6%1A%9FZ%5D%B8%7B"}]},
{"Desc":"","Delay":0,"Files":[{"Ext":"srt","Link":"https://www.shooter.cn/api/subapi.php?fetch=MTQwODc5NjY1N3w5VjJDUV9SYXpnNzdDeUtFRGFSQ0xEekdqWlp1YW9ZbEZCOUlBOG83RlJ4al9nOFFjc3ROcXJfeVFSTjcwaHVfZkdVeTdodC1jZ1c5RFNPMktMeDczQzVRVW1JMkFVX3VQQi1tTW9hOG5hVWNrOWxHQkVPM2NxUTNmWlkxTzBaSC0tMDcybmMtS1Y0STZHbFRtNF9rMll6WFJweFB0S0F2QlgxZUJQWT18NXOIF52s_qsZIuupexlMqRLZV4z8lzLX1nOSKVfskJo=\u0026nonce=%2Fu%E2%C4A%B7%DA%3EZ%ADr%A4m%CE%A3%B7"}]}]
</code></pre>

<p><img src="http://xiangshuai.github.io/resources/20140823204055.png" alt="" /></p>

<p>3.2.2 获取列表中的其中一个条目，根据此条目中的信息便可获取字幕文件的url地址，以上述条目中的第一条为例：</p>

<pre><code>https://www.shooter.cn/api/subapi.php?fetch=MTQwODc5NjY1N3wwMms0NGRCNC1UNmZPekdvLXJfRko2bU8zNkE1eGFyWndlRzFSOC1OZUFKOWpCRVMtVEc4MmZXTVlwNjR6NjdiZkpUZW12eG9JRjFWRHgwN01QWnc2Y01vZGlhRUl1NHMxbm1UT3ZPa1UwZXhheTc1SkJqRlhrOFc3cWQ1RjROWXg1aWRJTlJ5NDBfMGN4UjUwZjFJVC1SYzBqRTRwUU1CM2pRMGQtWT18oXpmBxVzkrWQj2gHyNldXfRT2FhEZI9eOPbRR8RNulc=&amp;nonce=%98%EA-%0F%BFr%AA%17%81%E0%5EU%83~%88%DB
</code></pre>

<blockquote><p>由于编码原因：所以需将上述url中的<code>\u0026</code>用<code>&amp;</code>代替</p></blockquote>

<p>通过进行上述url请求，即可请求道所需要的字幕文件。另外，经过测试可知，上述链接会随时间进行改变，所以每次得重新进行请求字幕列表，在根据选择列表中的条目进行构建url，直接用上述链接可能失效。</p>

<h2>4 脚本实现代码：</h2>

<p>根据以上分析的流程，用Python进行实现，通过简单操作便可方便的从射手网下载到字幕。</p>

<p>GitHub源代码: <a href="https://github.com/xiangshuai/shooter-subtitle-downloader">shooter-subtitle-downloader</a></p>

<h2>5 参考：</h2>

<ol>
<li>伯乐在线:<a href="http://blog.jobbole.com/75244/">“你所写过的最好的Python脚本是什么？”</a></li>
<li>GitHub: <a href="https://github.com/manojmj92/subtitle-downloader">subtitle-downloader</a></li>
<li>SparkMD5:<a href="http://www.ruby-doc.org/gems/docs/c/condo-1.0.4/app/assets/javascripts/condo/md5/spark-md5_js.html">http://www.ruby-doc.org/gems/docs/c/condo-1.0.4/app/assets/javascripts/condo/md5/spark-md5_js.html</a></li>
<li>MD5 Shootout:<a href="http://jsperf.com/md5-shootout/7">http://jsperf.com/md5-shootout/7</a></li>
<li>Python md5 module: <a href="http://effbot.org/librarybook/md5.htm">http://effbot.org/librarybook/md5.htm</a></li>
<li>MD5测试比对：<a href="http://www.cmd5.com/">http://www.cmd5.com/</a></li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>理解Https</title>
      <link href="https://xiangshuai.github.com//2014/08/understand-https/"/>
      <pubDate>2014-08-20T00:00:00+08:00</pubDate>
      <author>Kevin</author>
      <guid>https://xiangshuai.github.com//2014/08/understand-https</guid>
      <content:encoded><![CDATA[<h2>1、<a href="http://en.wikipedia.org/wiki/HTTP_Secure">HTTPS</a></h2>

<p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTPS，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。与传统http相比，https具有以下特点：</p>

<blockquote><ul>
<li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li>
<li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ul>
</blockquote>

<h2>2、基础知识</h2>

<p>简绍基本概念和术语，便于理解后续内容。</p>

<h3>2.1 公钥密码体制(<a href="http://en.wikipedia.org/wiki/Public-key_cryptography">public-key cryptography</a>)</h3>

<p><strong>公钥密码体制</strong>分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：</p>

<ul>
<li>加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。</li>
<li>解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。</li>
</ul>


<p>公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。</p>

<h3>2.2 对称加密算法(<a href="http://en.wikipedia.org/wiki/Symmetric-key_algorithm">symmetric key algorithms</a>)</h3>

<p>在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。</p>

<p><em>密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥。</em></p>

<h3>2.3 非对称加密算法(asymmetric key algorithms)</h3>

<p>在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。前面所说的公钥密码体制就是一种非对称加密算法，他的公钥和是私钥是不能相同的，也就是说加密使用的密钥和解密使用的密钥不同，因此它是一个非对称加密算法。</p>

<h3>2.4 <a href="http://en.wikipedia.org/wiki/RSA_(cryptosystem">RSA</a>)简介</h3>

<p>RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。</p>

<h3>2.5 签名和加密</h3>

<p>我们说加密，是指对某个内容加密，加密后的内容还可以通过解密进行还原。 比如我们把一封邮件进行加密，加密后的内容在网络上进行传输，接收者在收到后，通过解密可以还原邮件的真实内容。</p>

<p>这里主要解释一下签名，签名就是在信息的后面再加上一段内容，可以证明信息没有被修改过，怎么样可以达到这个效果呢？一般是对信息做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的信息内容。在把信息发送出去时，把这个hash值加密后做为一个签名和信息一起发出去。 接收方在收到信息后，会重新计算信息的hash值，并和信息所附带的hash值(解密后)进行对比，如果一致，就说明信息的内容没有被修改过，因为这里hash计算可以保证不同的内容一定会得到不同的hash值，所以只要内容一被修改，根据信息内容计算的hash值就会变化。当然，不怀好意的人也可以修改信息内容的同时也修改hash值，从而让它们可以相匹配，为了防止这种情况，hash值一般都会加密后(也就是签名)再和信息一起发送，以保证这个hash值不被修改。至于如何让别人可以解密这个签名，这个过程涉及到数字证书等概念，我们后面在说到数字证书时再详细说明，这里您先只需先理解签名的这个概念。</p>

<h2>3、加密通信过程的演化</h2>

<p>我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不需要知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：</p>

<h3>3.1 第一回合：</h3>

<pre><code>“客户”-&gt;“服务器”：你好

“服务器”-&gt;“客户”：你好，我是服务器

“客户”-&gt;“服务器”：？？？？
</code></pre>

<p>因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：</p>

<pre><code>“客户”-&gt;“服务器”：你好

“服务器”-&gt;“客户”：你好，我是服务器

“客户”-&gt;“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”

“黑客”-&gt;“客户”：你好，我是服务器
</code></pre>

<p>因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：</p>

<h3>3.2 第二回合：</h3>

<pre><code>“客户”-&gt;“服务器”：你好

“服务器”-&gt;“客户”：你好，我是服务器

“客户”-&gt;“服务器”：向我证明你就是服务器

“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]
</code></pre>

<p><em>注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。</em></p>

<p>为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。</p>

<p>“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。</p>

<p>假设“黑客”想冒充“服务器”：</p>

<pre><code>“黑客”-&gt;“客户”：你好，我是服务器

“客户”-&gt;“黑客”：向我证明你就是服务器

“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。

“客户”-&gt;“黑客”：？？？？
</code></pre>

<p>由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！</p>

<p>到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：</p>

<h3>3.3 第三回合：</h3>

<pre><code>“客户”-&gt;“服务器”：你好

“服务器”-&gt;“客户”：你好，我是服务器

“客户”-&gt;“服务器”：向我证明你就是服务器

“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]

“服务器”-&gt;“客户”：{你的余额是100元}[私钥|RSA]
</code></pre>

<p>注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。</p>

<p>这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：</p>

<h3>3.4 第四回合：</h3>

<pre><code>“客户”-&gt;“服务器”：你好

“服务器”-&gt;“客户”：你好，我是服务器

“客户”-&gt;“服务器”：向我证明你就是服务器

“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”-&gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    

“服务器”-&gt;“客户”：{OK，收到！}[密钥|对称加密算法]

“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”-&gt;“客户”：{你的余额是100元}[密钥|对称加密算法]
</code></pre>

<p>在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。</p>

<p>由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。</p>

<p>总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：</p>

<ul>
<li>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。</li>
<li>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。</li>
</ul>


<p>如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下3.3和3.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)</p>

<p>到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。</p>

<p>但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：</p>

<ul>
<li><p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p></li>
<li><p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p></li>
</ul>


<p>但是这个两个方法都有一定的问题，</p>

<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>

<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：</p>

<pre><code>“客户”-&gt;“黑客”：你好           //黑客截获“客户”发给“服务器”的消息

“黑客”-&gt;“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥

“客户”-&gt;“黑客”：向我证明你就是服务器

“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”
</code></pre>

<p>因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。</p>

<p>为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：</p>

<ul>
<li>证书的发布机构</li>
<li>证书的有效期</li>
<li>公钥</li>
<li>证书所有者（Subject）</li>
<li>签名所使用的算法</li>
<li>指纹以及指纹算法</li>
</ul>


<p>证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：</p>

<h3>3.5 第五回合：</h3>

<pre><code>“客户”-&gt;“服务器”：你好

“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥

“客户”-&gt;“服务器”：向我证明你就是服务器

“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]
</code></pre>

<p>注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：</p>

<h3>3.6 完整过程：</h3>

<p>step1： “客户”向服务端发送一个通信请求</p>

<pre><code>“客户”-&gt;“服务器”：你好
</code></pre>

<p>step2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有</p>

<pre><code>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书
</code></pre>

<p>step3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>

<pre><code>“客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。

“服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]
</code></pre>

<p>step4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>

<pre><code>“服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]

“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]
</code></pre>

<p>…… 继续其它的通信</p>

<h3>3.7 其它问题：</h3>

<p>上面的过程已经十分接近HTTPS的真实通信过程了，完全可以按照这个过程去理解HTTPS的工作原理。但是我为了方便解释，上面有些细节没有说到，有兴趣的人可以看下这部分的内容。可以跳过不看，无关紧要。</p>

<p><strong>【问题1】</strong></p>

<p>上面的通信过程中说到，在检查完证书后，“客户”发送一个随机的字符串给“服务器”去用私钥加密，以便判断对方是否真的持有私钥。但是有一个问题，“黑客”也可以发送一个字符串给“服务器”去加密并且得到加密后的内容，这样对于“服务器”来说是不安全的，因为黑客可以发送一些简单的有规律的字符串给“服务器”加密，从而寻找加密的规律，有可能威胁到私钥的安全。所以说，“服务器”随随便便用私钥去加密一个来路不明的字符串并把结果发送给对方是不安全的。</p>

<p><strong>〖解决方法〗</strong></p>

<p>每次收到“客户”发来的要加密的的字符串时，“服务器”并不是真正的加密这个字符串本身，而是把这个字符串进行一个hash计算，加密这个字符串的hash值(不加密原来的字符串)后发送给“客户”，“客户”收到后解密这个hash值并自己计算字符串的hash值然后进行对比是否一致。也就是说，“服务器”不直接加密收到的字符串，而是加密这个字符串的一个hash值，这样就避免了加密那些有规律的字符串，从而降低被破解的机率。“客户”自己发送的字符串，因此它自己可以计算字符串的hash值，然后再把“服务器”发送过来的加密的hash值和自己计算的进行对比，同样也能确定对方是否是“服务器”。</p>

<p><strong>【问题2】</strong></p>

<p>在双方的通信过程中，“黑客”可以截获发送的加密了的内容，虽然他无法解密这个内容，但是他可以捣乱，例如把信息原封不动的发送多次，扰乱通信过程。</p>

<p><strong>〖解决方法〗</strong></p>

<p>可以给通信的内容加上一个序号或者一个随机的值，如果“客户”或者“服务器”接收到的信息中有之前出现过的序号或者随机值，那么说明有人在通信过程中重发信息内容进行捣乱，双方会立刻停止通信。有人可能会问，如果有人一直这么捣乱怎么办？那不是无法通信了？ 答案是的确是这样的，例如有人控制了你连接互联网的路由器，他的确可以针对你。但是一些重要的应用，例如军队或者政府的内部网络，它们都不使用我们平时使用的公网，因此一般人不会破坏到他们的通信。</p>

<p><strong>【问题3】</strong></p>

<p>在双方的通信过程中，“黑客”除了简单的重复发送截获的消息之外，还可以修改截获后的密文修改后再发送，因为修改的是密文，虽然不能完全控制消息解密后的内容，但是仍然会破坏解密后的密文。因此发送过程如果黑客对密文进行了修改，“客户”和“服务器”是无法判断密文是否被修改的。虽然不一定能达到目的，但是“黑客”可以一直这样碰碰运气。</p>

<p><strong>〖解决方法〗</strong></p>

<p>在每次发送信息时，先对信息的内容进行一个hash计算得出一个hash值，将信息的内容和这个hash值一起加密后发送。接收方在收到后进行解密得到明文的内容和hash值，然后接收方再自己对收到信息内容做一次hash计算，与收到的hash值进行对比看是否匹配，如果匹配就说明信息在传输过程中没有被修改过。如果不匹配说明中途有人故意对加密数据进行了修改，立刻中断通话过程后做其它处理。</p>

<p>...后续会慢慢补充上来</p>

<h2>参考：</h2>

<h3>1. <a href="http://blog.163.com/magicc_love/blog/static/185853662201321423527263/">HTTPS与SSL</a></h3>

<h3>1. <a href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html">数字证书原理</a></h3>
]]></content:encoded>
    </item>
    
    <item>
      <title>Testing.....................</title>
      <link href="https://xiangshuai.github.com//2014/03/test/"/>
      <pubDate>2014-03-10T00:00:00+08:00</pubDate>
      <author>Kevin</author>
      <guid>https://xiangshuai.github.com//2014/03/test</guid>
      <content:encoded><![CDATA[<h1>欢迎使用马克飞象</h1>

<p>@(示例笔记本)[马克飞象|帮助|Markdown]</p>

<p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p>

<ul>
<li><strong>功能丰富</strong> ：支持高亮代码块、插入 <em>LaTex</em> 公式，工作学习好帮手</li>
<li><strong>得心应手</strong> ：支持插入图片，无论是本地上传/图片URL/拖放图片/直接截图粘贴，随心所欲</li>
<li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理</li>
</ul>


<blockquote><p>号外号外，离线客户端来啦！<a href="https://chrome.google.com/webstore/detail/%E9%A9%AC%E5%85%8B%E9%A3%9E%E8%B1%A1/kidnkfckhbdkfgbicccmdggmpgogehop/">点击下载</a></p></blockquote>

<hr />

<h3>Markdown简介</h3>

<blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown">维基百科</a></p></blockquote>

<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。</p>

<h4>代码块</h4>

<pre><code class="python">@requires_authorization
def somefunc(param1='', param2=0):
    '''A docstring'''
    if param1 &gt; param2: # interesting
        print 'Greater'
    return (param2 - param1 + 1) or None
class SomeClass:
    pass
&gt;&gt;&gt; message = '''interpreter
... prompt'''
</code></pre>

<h4>LaTex 公式</h4>

<p>$$  x = \dfrac{-b \pm \sqrt{b<sup>2</sup> - 4ac}}{2a} $$</p>

<h4>表格</h4>

<table>
<thead>
<tr>
<th style="text-align:left;"> Item      </th>
<th style="text-align:right;">    Value </th>
<th style="text-align:center;"> Qty  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> Computer  </td>
<td style="text-align:right;"> 1600 USD </td>
<td style="text-align:center;">  5   </td>
</tr>
<tr>
<td style="text-align:left;"> Phone     </td>
<td style="text-align:right;">   12 USD </td>
<td style="text-align:center;">  12  </td>
</tr>
<tr>
<td style="text-align:left;"> Pipe      </td>
<td style="text-align:right;">    1 USD </td>
<td style="text-align:center;"> 234  </td>
</tr>
</tbody>
</table>


<h3>印象笔记相关</h3>

<h4>笔记本和标签</h4>

<p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。自己纯手工输入无效。</p>

<h4>标题</h4>

<p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p>

<h4>快捷编辑</h4>

<p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p>

<blockquote><p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p></blockquote>

<h4>数据同步</h4>

<p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p>

<blockquote><p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p></blockquote>

<h4>离线存储</h4>

<p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p>

<blockquote><p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p></blockquote>

<h3>快捷键</h3>

<p>帮助    <code>Ctrl + /</code>
同步文档    <code>Ctrl + S</code>
创建文档    <code>Ctrl + Alt + N</code>
最大化编辑器    <code>Ctrl + Enter</code>
文档管理    <code>Ctrl + O</code>
系统菜单    <code>Ctrl + M</code></p>

<p>整行移动    <code>Alt + 上/下箭头</code>
删除整行    <code>Ctrl + D</code></p>

<p>加粗    <code>Ctrl + B</code>
插入图片    <code>Ctrl + G</code>
插入链接    <code>Ctrl + L</code>
提升标题    <code>Ctrl + H</code></p>

<h3>关于收费</h3>

<p><strong>马克飞象</strong>目前已正式发布，为新用户提供 10 天的试用期，试用期过后需要<a href="maxiang.info/vip.html">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p>

<h3>反馈与建议</h3>

<ul>
<li>微博：<a href="http://weibo.com/u/2788354117">@马克飞象</a>，<a href="http://weibo.com/ggock" title="开发者个人账号">@GGock</a></li>
<li>邮箱：<a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x68;&#117;&#x73;&#116;&#x67;&#x6f;&#99;&#107;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;">&#104;&#117;&#115;&#116;&#103;&#111;&#99;&#x6b;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a></li>
</ul>


<hr />

<p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
